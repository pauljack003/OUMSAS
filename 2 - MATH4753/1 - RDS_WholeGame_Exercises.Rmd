---
title: "R For Data Science Exercises"
author: "Paul Jackson"
date: "`r Sys.Date()`"
output: 
  html_document:
    toc: yes
    toc_float: yes
    number_sections: no
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# 1 Data visualization

Basics first:
```{r}
library(tidyverse)
library(palmerpenguins)
library(ggthemes)
```

## 1.2.5 Exercises

**1. How many rows are in penguins? How many columns?**

```{r}
glimpse(penguins)
```
344 rows, 8 columns.

**2. What does the `bill_depth_mm` variable in the `penguins` data describe? Read the help for `?penguins` to find out.**

Per the help file, the variable `bill_depth_mm` represents a number denoting bill depth in millimeters.

**3. Make a scatterplot of `bill_depth_mm` vs `bill_length_mm`. Describe the relationship between these two variables.**

```{r}
ggplot(penguins, aes(x = bill_length_mm, y = bill_depth_mm)) +
  geom_point(na.rm = TRUE)
```

I'm not sure here if I'd say there is a strong relationship. I do think looking at this by species would likely show some strong relationships, but that isn't the question.

**4. What happens if you make a scatterplot of `species` vs `bill_depth_mm`? What might be a better choice of geom?**

```{r}
ggplot(penguins, aes(x = bill_depth_mm, y = species)) +
         geom_point(na.rm = TRUE)
```

Because species is categorical, a scatterplot isn't very useful. But a boxplot can be a useful way to compare a categorical and numerical variable set.

```{r}
ggplot(penguins, aes(x = bill_depth_mm, y = species)) +
         geom_boxplot(na.rm = TRUE)
```

**5. Why does the following give an error and how would you fix it?**
```{r eval = FALSE}
ggplot(data = penguins) + 
  geom_point()
```

The above code doesn't have any mapping arguments via aes. Corrected code as shown:

```{r}
ggplot(data = penguins, mapping = aes(x = flipper_length_mm, y = body_mass_g)) + 
  geom_point()
```

**6. What does the `na.rm` argument do in `geom_point()`? What is the default value of the argument? Create a scatterplot where you successfully use this argument set to true.**

This argument ignores NA values in the dataset. Example usage below:

```{r}
ggplot(data = penguins, mapping = aes(x = flipper_length_mm, y = body_mass_g)) + 
  geom_point(na.rm = TRUE)
```

**7. Add the following caption to the plot you made in the previous exercise: "Data come from the palmerpenguins package."**

```{r}
ggplot(data = penguins, mapping = aes(x = flipper_length_mm, y = body_mass_g)) + 
  geom_point() + 
  labs(caption = "Data come from the palmerpenguins package.")
  
```

**8. Recreate the visualization shown. What aesthetic should `bill_depth_mm` be mapped to? And should it be mapped at the global or at the geom level?**

```{r}
ggplot(data = penguins, mapping = aes(x = flipper_length_mm, y = body_mass_g)) + 
  geom_point(aes(color = bill_depth_mm)) +
  geom_smooth()
```

The code is shown above. The variable `bill_depth_mm` should be mapped to the local point instance; assigning it to the global mapping would affect the line curve's color.

**9. Run this code, predict the output first. Did it do what you thought?**

My prediction is we'll get three color coded point areas, each color representing an island. Then we'll get a curved line fitting each of the islands, without the standard error shading. 

```{r}
ggplot(
  data = penguins,
  mapping = aes(x = flipper_length_mm, y = body_mass_g, color = island)
) +
  geom_point() +
  geom_smooth(se = FALSE)
```

My prediction was correct!

**10. Will these two graphs look different? Why/why not?**

I expect they will be the same. In the first, we're defining data and mapping globally. In the second, we're defining data and mapping locally.

```{r}
ggplot(
  data = penguins,
  mapping = aes(x = flipper_length_mm, y = body_mass_g)
) +
  geom_point() +
  geom_smooth()

ggplot() +
  geom_point(
    data = penguins,
    mapping = aes(x = flipper_length_mm, y = body_mass_g)
  ) +
  geom_smooth(
    data = penguins,
    mapping = aes(x = flipper_length_mm, y = body_mass_g)
  )
```

I was correct, they look the same.

## 1.4.3 Exercises

**1. Make a bar plot of species of penguins where you assign species to y. How does this change the bar plot?**

It will move the bars horizontal, off the y axis, as shown:

```{r}
ggplot(penguins, aes(y=species)) +
  geom_bar()
```

**2. How are the following two plots different? Which aesthetic, color or fill, is more useful for changing the color of bars?**

```{r}
#lets go side by side
library(patchwork)

p1 <- ggplot(penguins, aes(x = species)) +
  geom_bar(color = "red")

p2 <- ggplot(penguins, aes(x = species)) +
  geom_bar(fill = "red")

p1 + p2
```

Fill is far more useful for changing bar colors. 

**3. What does the bins argument in geom_histogram() do?**

It determines the number of bars/bins on the chart.

**4. Make a histogram of the `carat` variable in the `diamonds` dataset that is available when you load the tidyverse package. What binwidth is the most useful?**

```{r}

p1 <- ggplot(diamonds, aes(x=carat)) +
  geom_histogram(binwidth = 0.1)

p2 <- ggplot(diamonds, aes(x=carat)) +
  geom_histogram(binwidth = 0.5)

p3 <- ggplot(diamonds, aes(x=carat)) +
  geom_histogram(binwidth = 1.0)

p1 + p2 + p3
```

It looks like a binwidth value of .5 works best here.

## 1.5.5 Exercises

**1. Which variables in `mpg` are categorical? Which variables are numerical? How can you see this information when you run mpg?**

```{r}
glimpse(mpg)
```
* Categorical: manufacturer, model, trans, drv, fl, class
* Numerical: displ, year, cyl, cty, hwy

You can see this information by running the `glimpse()` dplyr function. 

**2. Make a scatterplot of `hwy` vs `displ`; then made a third numerical value to `color`, then `size`, then both `color` and `size`, then `shape`. How do these behave differently for categorical vs. numerical values?**

The shape argument fails when trying to employ a numerical variable; categorical is required. For both color and size, a numerical value is acceptable (although not neccessarily useful, as that will be context dependent).

The code below required me to use a categorical variable (I chose `drv`) in order for the RMD file to properly knit, as an example. 

```{r}
p1 <- ggplot(
  mpg, 
  aes(x = hwy, y = displ, color = cty)
) + 
  geom_point()

p2 <- ggplot(
  mpg, 
  aes(x = hwy, y = displ, size = cty)
) + 
  geom_point()

p3 <- ggplot(
  mpg, 
  aes(x = hwy, y = displ, size = cty, color = cty)
) + 
  geom_point()

p4 <- ggplot(
  mpg, 
  aes(x = hwy, y = displ, size = cty, color = cty, shape = drv)
) + 
  geom_point()

(p1 | p2) / (p3 | p4)
```

**3. In the scatterplot above, what happens if you map a third variable to linewidth?**

I don't have to map this to know. Nothing happens because there isn't a line specified in the aes() statement, so there isn't a line to vary the width of.

**4. What happens if you map the same variable to multiple aesthetics?**

ggplot will generate *something*, but it likely won't be useful. Imagine mapping an x axis onto the y axis -- you'll just get a line. Here is an example:

```{r}
ggplot(mpg, aes(x=cty, y=cty, size=cty)) +
  geom_point()
```

oooooooh, thanks for showing me that $35>10$. Needed a chart for that. LOL.

**5. Make a scatterplot of `bill_depth_mm` vs `bill_length_mm` and color the points by species. What does adding color reveal? What about faceting by species?**

```{r}
ggplot(penguins, aes(x = bill_length_mm, y = bill_depth_mm, color = species)) +
  geom_point()
```

Adding color makes it cleaar there is a strong linear relationship between the two variables once you account for the species.

Using faceting, we get a similar view:

```{r}
ggplot(penguins, aes(x = bill_length_mm, y = bill_depth_mm)) +
  geom_point() +
  facet_wrap(~species)
```

**6. Why does the following yield two seperate legends? How would you fix it to combine the legends?**

```{r eval=FALSE}
ggplot(
  data = penguins,
  mapping = aes(
    x = bill_length_mm, y = bill_depth_mm, 
    color = species, shape = species
  )
) +
  geom_point() +
  labs(color = "Species")
```

The problem above: only color has a renamed legend to Species, while shape does not. To fix this, just add in shape.

```{r}
ggplot(
  data = penguins,
  mapping = aes(
    x = bill_length_mm, y = bill_depth_mm, 
    color = species, shape = species
  )
) +
  geom_point() +
  labs(color = "Species",
       shape = "Species")
```

**7. Create the two stacked bar plots in the code shown below. What question does the first plot answer? The second one?

```{r}
ggplot(penguins, aes(x = island, fill = species)) +
  geom_bar(position = "fill")
ggplot(penguins, aes(x = species, fill = island)) +
  geom_bar(position = "fill")
```

The first bar plot tells us: which species live on each island? The second bar plot tells us: on which islands can a species be found? Similar, but slightly different questions.

## 1.6.1 Exercises

**1. Which of the two plots is saved from the below code?**

```{r eval=FALSE}

ggplot(mpg, aes(x = class)) +
  geom_bar()
ggplot(mpg, aes(x = cty, y = hwy)) +
  geom_point()
ggsave("mpg-plot.png")

```

It will be the second plot. `ggsave` will execute a save on the most recently run plot, whatever it is.

**2. What needs to change to save the plot as a PDF? How can you determine what types of files work with `ggsave()`?**

Just rename the output to *.pdf. If you look up `?ggsave` you can get details.

# 2. Workflow basics

## 2.5 Exercises

**1. Why does this code not work?**

```{r eval = FALSE}
my_variable <- 10
my_varÄ±able
```

Obviously there is a mismatch in variable names here. 

**2. Tweak these R commands so they run correctly.**

Given set:

```{r eval = FALSE}

libary(todyverse)

ggplot(dTA = mpg) + 
  geom_point(maping = aes(x = displ y = hwy)) +
  geom_smooth(method = "lm)

```

Fixed set:

```{r}
library(tidyverse)

ggplot(data = mpg, mapping = aes(x = displ, y = hwy)) + 
  geom_point() +
  geom_smooth(method = "lm")
```

**3. What happens with Option-Shift-K?**

Keyboard shortcuts are shown.

**4. Which of the two plots is saved? Why?**

```{r eval = FALSE}
my_bar_plot <- ggplot(mpg, aes(x = class)) +
  geom_bar()
my_scatter_plot <- ggplot(mpg, aes(x = cty, y = hwy)) +
  geom_point()
ggsave(filename = "mpg-plot.png", plot = my_bar_plot)
```

The plot saved to `my_bar_plot` is saved. The function defaults to the most recent plot unless given an express instruction to save something else.

# 3. Data transformation

Load prequisites.

```{r}
library(nycflights13)
```

## 3.2.5 Exercises

**1. In a single pipe for each condition, find all flights that:** 

* had an arrival delay of two or more hours; 
* flew to IAH or HOU; 
* were operated by UA, AA, DL;
* departed in July, August and September; 
* arrived more than two hours late, but didn't leave late; 
* were delayed by at least an hour, but made up over 30 minutes in flight.

```{r}
flights |>
 filter(arr_delay >= 120)

flights |>
  filter(dest %in% c("IAH", "HOU"))

flights |> 
  filter(carrier %in% c("UA", "AA", "DL"))

flights |> 
  filter(month %in% c(7:9))

flights |> 
  filter(arr_delay >= 120 & dep_delay <=0)

flights |> 
  filter(dep_delay >= 60 & dep_delay - arr_delay > 30)

```

**2. Sort flights to find the flights with the longest departure delays. Find the flights that left earliest in the morning, too.**

```{r}
#departure delays
flights |>
  arrange(desc(dep_delay))

#earliest in the AM
flights |>
  arrange(sched_dep_time)
```

**3. Sort flights to find the fastest flights.**

```{r}
flights |>
  mutate(speed = distance/(air_time/60)) |>
  arrange(desc(speed)) |>
  relocate(speed)
```

**4. Was there a flight on every day of 2013?**

```{r}
flights |>
  distinct(year, month, day) |>
  count()
```

Yes, there was.

**6. Does it matter what order you use filter() and arrange() if you're using both? Why/why not?**

Technically in terms of final output, no. But in terms of overhead, yes: you'd want to filter your data before you sort it -- because why waste system resources sorting through a massive dataset first and then filtering it? That wastes overhead for no real purpose.

## 3.3.5 Exercises

**1. Compare `dep_time`, `sched_dep_time`, and `dep_delay`. How would you expect these to be related?**

The difference between scheduled departure time and actual departure time represents the calculated delay.

**2. Brainstorm ways to select `dep_time`, `dep_delay`, `arr_time` and `arr_delay` from flights.**

```{r}
flights |>
  select(c(dep_time, dep_delay, arr_time, arr_delay))

flights |>
  select(starts_with("dep_") | starts_with("arr_"))
```

**3. What happens if you specify the name of the same variable multiple times in a select() call?**

Nothing. You can only obtain that variable once, and once obtained, it's there. You can call it over and over but it won't accomplish anything.

**4. What does the `any_of()` function do? Why might it help with this vector?**

```{r eval = FALSE}
variables <- c("year", "month", "day", "dep_delay", "arr_delay")
```

It makes a select call more efficient, instead of having to write each variable individually. This way variables can be swapped without affecting code functions. It also allows for the vector to have an error, calling a variable that doesn't exist: R will simply skip that variable and move on without throwing an error up.

Example:

```{r eval = FALSE}
flights |>
  select(any_of(variables))
```


**5. Does the result of running the following code surprise? How do the select helpers deal with upper and lower case by default? Can you change the default?**

```{r}
flights |> select(contains("TIME"))
```


R by default is not case sensitive, one its well known traits. The argument `ignore.case = FALSE` can be added to the contains() statement to force case sensitivity in string search.


**6. Rename `air_time` to `air_time_min` to indicate units of measurement and move it to the beginning of the dataframe.**

```{r}
flightdata <- flights |>
  rename(air_time_min = air_time) |>
  relocate(air_time_min)
```

**7. Why doesn't the following code work, and what does the error shown mean?**

```{r eval = FALSE}
flights |> 
  select(tailnum) |> 
  arrange(arr_delay)
```

The error is clear that the arr_delay object doesn't exist because it wasn't subject to the select statement that came before it. 

## 3.5.7 Exercises

**1. Which carrier has the worst average delays?**

```{r}
flights |>
  summarise(
    avgdelay = mean(dep_delay, na.rm = TRUE),
    .by = carrier,
  ) |>
  arrange(desc(avgdelay))
```

Frontier Airlines (F9) has the worst delays.

**2. Find the flights that are most delayed upon departure from each destination.**

```{r}
flights |>
  group_by(dest) |>
  slice_max(dep_delay, n=1, with_ties = FALSE) |>
  relocate(dest)
```

This shows the most delayed flight from each destination in the dataset.

**3. How do delays vary over the course of the day? Illustrate your answer with a plot?**

```{r}
flights |>
  group_by(hour) |>
  summarize(avgdepdelay = mean(dep_delay, na.rm = TRUE)) |> 
  ggplot(aes(x = hour, y = avgdepdelay)) +
  geom_smooth()
```

Average delays slowly increase throughout the day, and peak around 7pm before declining. (This makes sense, in that delays tend to stack up over time.)

**4. What happens if you supply a negative `n` to `slice_min()` and friends?**

The `slice_min` function will sort/arrange the observations in the intended order (in this case: ascending), but it won't actually slice anything off because it can't slice a negative number. The similar holds true for `slice_max` (where observations are sorted in descending order).

**5. Explain what `count()` does in terms of the dplyr verbs you just learned. What does the `sort` argument to `count()` do?**

This is simple: `count()` simply counts observations in a given group. Including the `sort = TRUE` argument will sort the counts in descending order.

**6. Suppose we have the following dataframe: follow the instructions.**

```{r}
df <- tibble(
  x = 1:5,
  y = c("a", "b", "a", "a", "b"),
  z = c("K", "K", "L", "L", "K")
)
```

**6a.**

This code will group by y. The tibble shows the groupings but we haven't done anything with the two groups.

```{r}
df |>
  group_by(y)
```

**6b.**

This code will arrange y in ascending order.

```{r}
df |>
  arrange(y)
```

**6c.**

This code will show the mean of x for each value of y: a, b.

```{r}
df |>
  group_by(y) |>
  summarize(mean_x = mean(x))
```

**6d.**

This code will group by y, then z, and then summarize the means of x within each combined grouping.

```{r}
df |>
  group_by(y, z) |>
  summarize(mean_x = mean(x))
```

**6e.**

This code will look almost the same as the one above, but a close inspection will show that the groups have been dropped after analysis.

```{r}
df |>
  group_by(y, z) |>
  summarize(mean_x = mean(x), .groups = "drop")
```

**6f.**

Summarize merely shows the mean values by group -- it does not show other values, nor does it insert a new variable into the dataframe.

Mutate will perform similar calculations but maintains each individual observation and adds a new variable to the dataframe.

```{r}
df |>
  group_by(y, z) |>
  summarize(mean_x = mean(x))

df |>
  group_by(y, z) |>
  mutate(mean_x = mean(x))
```

# 4. Workflow: code style

## 4.6 Exercises

**1. Fix this nightmare code.**

```{r eval = FALSE}
flights|>filter(dest=="IAH")|>group_by(year,month,day)|>summarize(n=n(),
delay=mean(arr_delay,na.rm=TRUE))|>filter(n>10)

flights|>filter(carrier=="UA",dest%in%c("IAH","HOU"),sched_dep_time>
0900,sched_arr_time<2000)|>group_by(flight)|>summarize(delay=mean(
arr_delay,na.rm=TRUE),cancelled=sum(is.na(arr_delay)),n=n())|>filter(n>10)
```

Here's the tidy code:

```{r}
flights |>
  filter(dest == "IAH") |>
  group_by(year, month, day) |>
  summarize(
    n = n(),
    delay = mean(arr_delay,na.rm=TRUE)
    ) |> 
  filter(n>10)

flights |> 
  filter(
    carrier == "UA",
    dest %in% c("IAH","HOU"),
    sched_dep_time > 0900,
    sched_arr_time < 2000
    ) |>
  group_by(flight) |>
  summarize(
    delay = mean(arr_delay,na.rm=TRUE),
    cancelled = sum(is.na(arr_delay)),n=n()) |>
  filter(n>10)
```



# 5 Data tidying

## 5.2.1 Exercises

**(1. This question omitted, as it seems far too self explanatory to analyze here.)**

You either know how to look at a table and make sense of its structure, or you do not. 

**2. Reshape `table2` to make it tidy, and do the same for `table3`. (The question asks for a conceptual sketch but I found it easier just to do the pivoting and transforms vs writing about how I'd do the same thing.)**

```{r}
table2 |>
  pivot_wider(
    names_from = type,
    values_from = count
  ) |> 
  mutate(rate = cases / population * 10000)
```

```{r}
table3 |>
  separate_wider_delim(
    cols = rate, 
    delim = "/", 
    names = c("cases", "population"),
  ) |>
  mutate(
    cases = as.numeric(cases),
    population = as.numeric(population),
    rate = cases / population * 10000
  )
```

# 6. Workflow: scripts and projects

There are no exercises of note here.

# 7. Data import

Fun way to bring in data from the web. You can use a web address in place of the relative path on a local machine!

```{r}
students <- read_csv("https://pos.it/r4ds-students-csv", na = c("N/A", ""))

#clean variable names in a single command!
students |> janitor::clean_names()
```

## 7.2.4 Exercises

**1. What function would you use to read a file where fields were separated with "|"?**

I'd use `read_delim()` since it can handle any defined delimiter.

**2. Apart from `file`, `skip` and `comment`, what other arguments do `read_csv()` and `read_tsv()` have in common?**

All of them. As the help notes, both functions are special cases of the more general `read_delim()` function.

**3. What is the most important set of arguments for `read_fwf`?**

In general, any argument that doesn't have a default value in the function will be critical -- because without it being specified, the function cannot operate. In the case of `read_fwf()` the following arguments are required: file, col_positions. It's critical to have these two arguments correctly specified.

**4. To read the following text into a data frame, what argument to `read_csv()` do you need to specify?**

`"x,y\n1,'a,b'"`

```{r}
df <- read_csv("x,y\n1,'a,b'", quote = "'")
```

**5. Identify what is wrong with each of the inline CSV files.**

```{r eval = FALSE}
read_csv("a,b\n1,2,3\n4,5,6")
read_csv("a,b,c\n1,2\n1,2,3,4")
read_csv("a,b\n\"1")
read_csv("a,b\n1,2\na,b")
read_csv("a;b\n1;3")
```

Line 1: two column headers, three values in each row.
Line 2: three column headers, two values row 2, four values row 3.
Line 3: no rows are read in
Line 4: mixes numericacl and text, variables set to character as a result.
Line 5: ; isn't a named delimiter so we get one column with one observation.

**6. Practice referring to non-syntactic names.**

```{r}
annoying <- tibble(
  `1` = 1:10,
  `2` = `1` * 2 + rnorm(length(`1`))
)
```

a. Extracting the variable called 1

```{r}
annoying |> 
  select(`1`)
```

b. Plotting 1 vs 2

```{r}
ggplot(annoying, aes(x = `1`, y = `2`)) +
  geom_point()
```

c. Create a new column called 3, which is 2/1

```{r}
annoying |> 
  mutate(`3` = `2` / `1`)
```

d. Renaming columns to one, two and three

```{r}
annoying |> 
  mutate(`3` = `2` / `1`) |> 
  rename(
    "one" = `1`,
    "two" = `2`,
    "three" = `3`
  )
```



# 8. Workflow: getting help

There are no exercises of note here.


